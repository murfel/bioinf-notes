# Выравнивание двух генов

**Алгоритм Нидлмана — Вунша**

## Что выравниваем?
Два **уже собранных** гена (или генома: набора всех генов) друг на друга. Ген - строка над алфавитом ACGT. Считаем, что нет ошибок от прочтения на секвенаторе.
Все различия между двумя генами - от эволюции организмов.

Цель
* Если один и тот же организм, то скорее всего один из генов будет референсный, второй ген конкретного организма.
Хочется понять индивидуальные мутации конкретного организма относительно референсного. 
* Если разные организмы, понять степень родства, построить филогенетическое дерево.

Гены представлены как строки из нуклеотидов ACGT (4 символа в алфавите) или аминокислот (20 символов в алфавите).
Если один и тот же организм или организмы родственные, интереснее смотреть на нуклеотиды (больше информации).
Если разные и далёкие, достаточно на аминокислоты.

## Постановка задачи выравнивания
По данным строкам `t` и `s`, состоящим из алфавита ACGT, найти две _выравненные строки_, максимизирующие метрику `w`.

```
t = AGTAG
s = AGCCA

t  A G - T A G
s  A G C C A -
   M M G X M G - комментарий

M - match (совпадение)
X - mismatch (замена)
G - gap (in/del, вставка / удаление)
```

## Резюме решения
Динамическое программирование, взвешенный алгоритм Левенштейна, только функция максимизируется.

Дополнительные модификации для скоринга мисматчей (одни мисматчи хуже чем другие) 
и гэпов (штраф за открытие последовательности гэпов: один длинный гэп лучше, чем серия маленьких).

## Определения
* `s`, `t` - строки из символов A, C, G, T
* `w` - метрика/скор близости двух строк, число.
  * Чем больше, тем ближе строки.
  * Две тождественные строки имеют значение `w = len(s) = len(t)`.
* `opt` - матрица метрик для каждой пары префиксов строк, размер `len(s) + 1` на `len(t) + 1`.
  * В клетке `opt[i, j]` стоит значение метрики `w` для строк `s[:i]`, `t[:j]`
    (префиксы длины i и j соответственно, с последними символами `s[i - 1]` и `t[j - 1]`).

### Метрика
Просто расстояние Левенштейна не подходит, т.к. мисматч менее хуже, чем гэп.
Воспользуемся взвешенным алгоритмом Левенштейна.

Метрика `w = #M + mu #X + delta #G -> max`

`mu < 0` - штраф за мисматч.

`delta < 0` - штраф за гэп.

`delta < mu`, гэп хуже мисматча.

### База динамики
`opt[0, 0] = 0` - значение метрики двух пустых подстрок `s` и `t` равно нулю.

При реализации все остальные ячейки матрицы удобно заполнить отрицательными бесконечностями (NINF = -1000000000).

### Переход динамики
Динамика вперёд.

Для каждой пары префиксов, наращиваем строки на один символ: 
только первую, только вторую, обе сразу (вниз, вправо, по диагонали вправо-вниз).

```
s [G A T T]
         i
t [G C A T G]
           j

i, j - индексы последних символов
```
_Примечание:_ `s[:-1]` - строка s без последнего символа, то есть `s[0...i-1]` включая оба конца.

1. Match. Скор `+1 + opt(s[:-1], t[:-1])`
2. Mismatch. Скор `+mu + opt(s[:-1], t[:-1])`
3. Gap.
  * Удаление (из первой строки) (пропуск в первой строке). Скор `+delta + opt(s[:-1], t])`
  * Вставка (в первой строке) (пропуск во второй строке). Скор `+delta + opt(s, t[:-1])`

То же самое в коде:
1. Match: `opt[i + 1, j + 1] = 1 + opt[i, j]`
2. Mismatch `opt[i + 1, j + 1] = mu + opt[i, j]`
3. Gap - удаление - `opt[i, j + 1] = delta + opt[i, j]`
4. Gap - вставка - `opt[i + 1, j] = delta + opt[i, j]`

### Порядок обходов
Динамика вперёд, вниз-направо или направо-вниз - оба варианта работают. Вниз-направо:

```
for i in range(len(s) + 1):
    for j in range(len(t) + 1):
        ...
```

### Пример
+1 за совпадение символов, −1 за несовпадение и −2 за пропуски.

Матрица `opt`.

```
      G  C  A  T  G
   0 -2 -4 -6 -8 -10
G -2  1 -1 -3 -5 -7
A -3 -1  0  0 -2 -4
T -6 -3 -2 -1  1 -1
T -8 -5 -4 -3  0  0
```

### Восстановление ответа
Значение метрики, достигаемое на ответе, хранится в правом нижнем углу матрицы `opt[len(s), len(t)]`.

Два способа получить ответ (две выравненные строки):
- Восстановление ответа. Восстанавливаем, откуда мы пришли, ретроспективно двигаяся от правого нижнего угла назад по одному из трёх направлений, где значение метрики плюс цена перехода совпадает с текущим значением метрики.
- Предподсчёт. Изначально во время подсчёта метрики также насчитываем матрицу предков.
  - Чуть проще написать, но лишная память. Но у нас много памяти, поэтому нет смысла упражняться в индексах.

## Выбор весов мисметчей

#### Виды мутаций с точки зрения аминокислот
- silent (невидимая)
  - TGU -> TGC (цистеин на цистеин) 
  - триплет аминокислоты заменился на триплет **той же самой** аминокислоты
- missence (замена)
  - TGU -> TGG (цистеин на триптофан)
  - триплет одной аминокислоты заменился на триплет **другой** аминокислоты
- non-sense (бессмысленная)
  - TGU -> TGA (цистеин на стоп-кодон)
  - замена аминокислоты на стоп-кодон

#### Виды мутаций замены (missence)
- Не слишком плохо, если замена аминокислоты на другую такого же типа 
(полярная, такого же размера), белок сохранит схожую структуру, будет рабочий
=> будет выполнять примерно такие же функции => гены/организмы остаются достаточно близки.
- Плохо, если полярная аминокислота заменяется на неполярную.

Для учета **схожести заменённых аминокислот** разработаны кастомные **матрицы весов**.
На диагонали большие числа, у групп схожих аминокислот попарно поменьше, 
у всех остальных пар - отрицательные числа.

Примеры матриц весов.
- BLOSUM62. Построена статистически на корпусе всех референсных геномов с похожестью по Левенштейну < 62%.
- PAM - point accepted mutations. Взяли близкородственные белки, насколько часто происходят мутации.
  - PAM1 - вероятность 1 мутации на 100 нуклеотидов.
  - PAM250 = PAM1^250 - вероятность 250 мутаций на 100 нуклеотидов. 

blosum62 в виде питонского словаря: [gist](https://gist.github.com/murfel/346c5068f90c8f1a59ff4b94d6b16c29)

## Выбор весов гэпов

```
ref A G T T T T T T C A
x'  A G - T - T - - C A
x'' A G T T - - - - C A
```
Метрики `x'` и `x''` совпадают `w(x') = w(x'')`, 
но строка выравнивания `x''` более вероятна с точки зрения эволюции
(один длинный гэп вероятнее, чем три маленьких).

Исходная метрика не различает ситуации x' и x''.
Будем штрафовать `ro` за открытие гэпа и `sigma` за каждый шаг гэпа, включая первый.

### Реализация 1 - N^3, длинные переходы
Этот вариант заходит в контест в задачу подсчёта скора. В восстановление ответа наверняка тоже, но я не пробовала.

Наращиваем строку из префикса длины (i, j) с последними символами `s[i - 1]`, `t[j - 1]`. Для каждого из двух гэпов, начинающихся в s или t отсюда, сразу насчитаем всех возможные длины. Для каждой строки таких гэпов линейное количество. N^2 состояний, каждый переход за линию, отсюда N^3.

`opt[i, k + 1] = opt[i, j] + GAP_OPENING + GAP * (k + 1 - j)` для `k` из `[j, len(t))` - открываем гэп длиной `(k + 1 - j)` в первой строке и съедам столько же символов из второй строки.

Аналогичная формула для открытия гэпа во второй строке.

С точки зрения реализации для вывода только скора (без восстановления ответа), это изменение двух строчек: заменить ифы гэпов на форики и заменить формулу скора на новую.

Восстанавливать ответ по этой матрице чуть интереснее в случае, когда предшественник - гэп. Нужно сделать форик, чтобы найти предшественника. Если насчитывать матрицу предшественников сразу, то будет проще: форик нужен будет только чтобы напечатать нужно количество гэпов в ответе.

### Реализация 2 - N^2, три матрицы
Об этом удобнее думать не как три матрицы, а как одна матрица с тройками `(w0, w1, w2)`.

В исходном алгоритме штраф GAP_OPENING был равен нулю, у нас было одно состояние, и всё работало. Сейчас нам нужно дополнительное состояние, чтобы поддерживать факт "открыт ли гэп", и так как строки две, то это тернарное состояние: не открыт, открыт в первой строке, открыт во второй строке. Получается теперь состояние: `opt[i + 1, j + 1, x]`, где `x = 0, 1, 2`, - оптимальный скор для строки с последними символами s[i], t[j] и в состоянии открытости гэпа `x`. Так как третье измерение имеет константный размер 3, то можно втащить его в исходное состояние `opt[i, j]` как тройку значений. Теперь у нас одна матрица, хранящая тройки.

Теперь `opt[i + 1, j + 1]` хранит тройку (w0, w1, w2) - это три скора для префиксов с последними символами `s[i]`, `t[j]`.
  * `w0` - скор, если последнее действие было матч/мисматч.
  * `w1`, `w2` - скор, если последнее действие было гэпом в первой или второй строке соответственно. 

Переходы:
* Обозначения: `x max= y` то же самое что `x = max(x, y)`.
* Пусть (w0, w1, w2) - это скоры из `opt[i, j]`.
  * `score = MATCH if (s[i] == t[j]) else MISMATCH`
  * `opt[i + 1, j + 1, 0] max= w0 + score`
  * `opt[i + 1, j + 1, 0] max= w1 + score`
  * `opt[i + 1, j + 1, 0] max= w2 + score`
* Гэп в первой строке, поедаем символ из второй строки.
  * `opt[i, j + 1, 1] max= w0 + GAP_OPENING + GAP`
  * `opt[i, j + 1, 1] max= w1 + GAP`
* Гэп во второй строке, поедаем символ из первой строки.
  * `opt[i + 1, j, 2] max= w0 + GAP_OPENING + GAP`
  * `opt[i + 1, j, 2] max= w2 + GAP`


## Заметки по реализации

В любой динамике удобно завести функцию `relax`:
```
def relax(i, j, k, value):
    if opt[i, j, k] < value:
        opt[i, j, k] = value
```

Тогда переход записывается чуть проще: `relax(i + 1, j + 1, 0, w0 + score)`.
